variable:
    program ::= program_heading ';' program_block '.'
    program_heading ::= 'program' identifier ('(' program_parameter_list ')')?
    program_parameter_list ::= identifier_list
    program_block ::= block
    block ::= label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part statement_part
    label_declaration_part ::= ('label' label (',' label)* ';')?
    constant_definition_part ::= ('const' (constant_definition ';')+)?
    type_definition_part ::= ('type' (type_definition ';')+)?
    variable_declaration_part ::= ('var' (variable_declaration ';')+)?
    procedure_and_function_declaration_part ::= ((procedure_declaration | function_declaration) ';')*
    statement_part ::= compound_statement
    constant_definition ::= identifier '=' constant
    constant ::= sign? (unsigned_number | constant_identifier) | character_string
    constant_identifier ::= identifier
    type_definition ::= identifier '=' type_denoter
    type_denoter ::= type_identifier | new_type
    new_type ::= new_ordinal_type | new_structured_type | new_pointer_type
    simple_type_identifier ::= type_identifier
    structured_type_identifier ::= type_identifier
    pointer_type_identifier ::= type_identifier
    type_identifier ::= identifier
    simple_type ::= ordinal_type | real_type_identifier
    ordinal_type ::= new_ordinal_type | ordinal_type_identifier
    new_ordinal_type ::= enumerated_type | subrange_type
    ordinal_type_identifier ::= type_identifier
    real_type_identifier ::= type_identifier
    enumerated_type ::= '(' identifier_list ')'
    identifier_list ::= identifier (',' identifier)*
    subrange_type ::= constant '..' constant
    structured_type ::= new_structured_type | structured_type_identifier
    new_structured_type ::= 'packed'? unpacked_structured_type
    unpacked_structured_type ::= array_type | record_type | file_type
    array_type ::= 'array' '[' index_type (',' index_type)* ']' 'of' component_type
    index_type ::= ordinal_type
    component_type ::= type_denoter
    record_type ::= 'record' field_list 'end'
    field_list ::= ((fixed_part (';' variant_part)? | variant_part) ';'?)?
    fixed_part ::= record_section (';' record_section)*
    record_section ::= identifier_list ':' type_denoter
    field_identifier ::= identifier
    variant_part ::= 'case' variant_selector 'of' variant (';' variant)*
    variant_selector ::= (tag_field ':')? tag_type
    tag_field ::= identifier
    variant ::= case_constant_list ':' '(' field_list ')'
    tag_type ::= ordinal_type_identifier
    case_constant_list ::= case_constant (',' case_constant)*
    case_constant ::= constant
    set_type ::= 'set' 'of' base_type
    base_type ::= ordinal_type
    file_type ::= 'file' 'of' component_type
    pointer_type ::= new_pointer_type | pointer_type_identifier
    new_pointer_type ::= '^' domain_type
    domain_type ::= type_identifier
    variable_declaration ::= identifier_list ':' type_denoter
    variable_access ::= entire_variable | component_variable | identified_variable | buffer_variable
    entire_variable ::= variable_identifier
    identified_variable ::= pointer_variable '^'
    pointer_variable ::= variable_access
    variable_identifier ::= identifier
    component_variable ::= indexed_variable | field_designator
    indexed_variable ::= array_variable '[' index_expression (',' index_expression)* ']'
    array_variable ::= variable_access
    index_expression ::= expression
    field_designator ::= record_variable '.' field_specifier | field_designator_identifier
    record_variable ::= variable_access
    field_specifier ::= field_identifier
    buffer_variable ::= file_variable '^'
    file_variable ::= variable_access
    procedure_declaration ::= procedure_heading ';' directive | procedure_identification ';' procedure_block | procedure_heading ';'procedure_block
    procedure_heading ::= 'procedure' identifier formal_parameter_list?
    procedure_identification ::= 'procedure' procedure_identifier
    procedure_identifier ::= identifier
    procedure_block ::= block
    function_declaration ::= function_heading ';' directive | function_identification ';' function_block | function_heading ';' function_block
    function_heading ::= 'function' identifier formal_parameter_list? ':' result_type
    function_identification ::= 'function' function_identifier
    function_identifier ::= identifier
    result_type ::= simple_type_identifier | pointer_type_identifier
    function_block ::= block
    formal_parameter_list ::= '(' formal_parameter_section (';' formal_parameter_section)* ')'
    formal_parameter_section ::= value_parameter_specification | variable_parameter_specification | procedural_parameter_specification | functional_parameter_specification | comformant_array_parameter_specification
    value_parameter_specification ::= identifier_list ':' type_identifier
    variable_parameter_specification ::= 'var' identifier_list ':' type_identifier
    procedural_parameter_specification ::= procedure_heading
    functional_parameter_specification ::= function_heading
    comformant_array_parameter_specification ::= value_conformant_array_specification | variable_comformant_array_specification
    value_conformant_array_specification ::= identifier_list ':' comformant_array_schema
    variable_comformant_array_specification ::= 'var' identifier_list ':' comformant_array_schema
    comformant_array_schema ::= packed_conformant_array_schema | unpacked_conformant_array_schema
    packed_conformant_array_schema ::= 'packed' 'array' '[' index_type_specification ']' 'of' type_identifier
    unpacked_conformant_array_schema ::= 'array' '[' index_type_specification (';' index_type_specification)* ']' 'of' (type_identifier | comformant_array_schema)
    index_type_specification ::= identifier '..' identifier ':' ordinal_type_identifier
    bound_identifier ::= identifier
    expression ::= simple_expression (('=' | relational_operator) simple_expression)?
    simple_expression ::= sign? term (adding_operator term)*
    term ::= factor (multiplying_operator factor)*
    factor ::= bound_identifier | variable_access | unsigned_constant | function_designator | set_constructor | '(' expression ')' | 'not' factor
    unsigned_constant ::= unsigned_number | character_string | constant_identifier | 'nil'
    set_constructor ::= '[' (member_designator (',' member_designator)*)? ']'
    member_designator ::= expression ('..' expression)?
    Boolean_expression ::= expression
    function_designator ::= function_identifier actual_parameter_list?
    actual_parameter_list ::= '(' actual_parameter (',' actual_parameter)* ')'
    actual_parameter ::= expression | variable_access
    statement ::= (label ':')? (simple_statement | structured_statement)
    simple_statement ::= (assignment_statement | procedure_statement | goto_statement)?
    assignment_statement ::= (variable_access | function_identifier) ':=' expression
    procedure_statement ::= procedure_identifier (actual_parameter_list? | read_parameter_list | readln_parameter_list | write_parameter_list | writeln_parameter_list)
    goto_statement ::= 'goto' label
    structured_statement ::= compound_statement | conditional_statement | repetitive_statement | with_statement
    statement_sequence ::= statement (';' statement)*
    compound_statement ::= 'begin' statement_sequence 'end'
    conditional_statement ::= if_statement | case_statement
    if_statement ::= 'if' Boolean_expression 'then' statement else_part?
    else_part ::= 'else' statement
    case_statement ::= 'case' case_index 'of' case_list_element (';' case_list_element)* ';'? 'end'
    case_list_element ::= case_constant_list ':' statement
    case_index ::= expression
    repetitive_statement ::= repeat_statement | while_statement | for_statement
    repeat_statement ::= 'repeat' statement_sequence 'until' Boolean_expression
    while_statement ::= 'while' Boolean_expression 'do' statement
    for_statement ::= 'for' control_variable ':=' initial_value ('to' | 'downto') final_value 'do' statement
    control_variable ::= entire_variable
    initial_value ::= expression
    final_value ::= expression
    with_statement ::= 'with' record_variable_list 'do' statement
    record_variable_list ::= record_variable (',' record_variable)*
    field_designator_identifier ::= identifier
    read_parameter_list ::= '(' (file_variable ',')? variable_access (',' variable_access)* ')'
    readln_parameter_list ::= ('(' (file_variable | variable_access) (',' variable_access)* ')')?
    write_parameter_list ::= '(' (file_variable ',')? write_parameter (',' write_parameter)* ')'
    write_parameter ::= expression (':' expression (':' expression)?)?
    writeln_parameter_list ::= ('(' (file_variable | write_parameter) (',' write_parameter)* ')')?
    directive ::= identifier
    label ::= digit_sequence
terminal:
    letter ::= [a-zA-Z]
    digit ::= [0-9]
    character ::= [#x0-#x10FFFF]
    special_symbol ::= [+*=/<>.,:;()] | '-' | '^' | '[' | ']' | '<>' | '<=' | '>=' | ':=' | '..' | word_symbol
    word_symbol ::= 'and' | 'array' | 'begin' | 'case' | 'const' | 'div' | 'do' | 'downto' | 'else' | 'end' | 'file' | 'for' | 'function' | 'goto' | 'if' | 'in' | 'label' | 'mod' | 'nil' | 'not' | 'of' | 'or' | 'packed' | 'procedure' | 'program' | 'record' | 'repeat' | 'set' | 'then' | 'to' | 'type' | 'until' | 'var' | 'while' | 'with'
    signed_number ::= signed_integer | signed_real
    signed_real ::= sign? unsigned_real
    signed_integer ::= sign? unsigned_integer
    unsigned_number ::= unsigned_integer | unsigned_real
    sign ::= '+' | '-'
    unsigned_real ::= digit_sequence '.' fractional_part ([eE] scale_factor)? | digit_sequence [eE] scale_factor
    unsigned_integer ::= digit_sequence
    fractional_part ::= digit_sequence
    scale_factor ::= sign? digit_sequence
    digit_sequence ::= digit+
    character_string ::= "'" string_element+ "'"
    string_element ::= apostrophe_image | string_character
    apostrophe_image ::= "''"
    string_character ::= character - "'"
    multiplying_operator ::= '*' | '/' | 'div' | 'mod' | 'and'
    adding_operator ::= '+' | '-' | 'or'
    relational_operator ::= '=' | '<>' | '<' | '>' | '<=' | '>=' | 'in'
    identifier ::= letter (letter | digit)*
ignore:
    space ::= [#x9#xA#xD#x20]
    commentary ::= ('{' | '(*') (character* - character* ('}' | '*)') character*) ('}' | '*)')
